function [M,varargout] = batch_inter_sensor_metrics(beat1, beat2, metric,varargin)
% Assumes that beat1 and beat2 are batches of beats of the same length    
% beat1: [L x N1], beat2: [L x N2]
    [L1, N1] = size(beat1);
    [L2, N2] = size(beat2);

    if L1 ~= L2
        error('Beats must have the same length.');
    end
    
    M = zeros(N1, N2); %Pairwise metric matrix
    if (strcmp(metric,'xcorr') | strcmp(metric,'jsd'))
        O = zeros(N1, N2); % Optimal lags matrix or sqrt(JSD) matrix
    end
    %C = zeros(N1, N2);  % Cross-correlation matrix
    breakflag = 0; %used in JSD and EMD cases
    for i = 1:N1
        b1 = beat1(:, i);
        for j = 1:N2
            b2 = beat2(:, j);
            switch metric
                case 'xcorr'
                    b1 = b1 - mean(b1);  % Center
                    b1 = b1 / norm(b1);  % Normalize
                    b2 = b2 - mean(b2);
                    b2 = b2 / norm(b2);

                    % Compute normalized cross-correlation
                    [xcorr_vals,lags] = xcorr(b1, b2, 'coeff');
                    [max_corr, max_idx] = max(xcorr_vals);
                    M(i, j) = max_corr;  % Take maximum value
                    O(i,j) = lags(max_idx);
                case 'mse'
                    diff = b1 - b2;
                    M(i,j) = mean(diff.^2);
                case 'nrmse'
                    diff = b1 - b2;
                    rmse = sqrt(mean(diff.^2));
                    range_val = max([b1; b2]) - min([b1; b2]);
                    M(i,j) = rmse / range_val;
                case 'cosine'
                    b1n = b1 - mean(b1);
                    b2n = b2 - mean(b2);
                    cos_sim = dot(b1n, b2n) / (norm(b1n) * norm(b2n));
                    M(i,j) = cos_sim;
                case 'jsd'                    
                    nbins = varargin{1};
                    beat1 = beat1 - mean(beat1);  % Center
                    beat1 = beat1 / norm(beat1);  % Normalize
                    beat2 = beat2 - mean(beat2);
                    beat2 = beat2 / norm(beat2);
                    %Check distribution of extreme values (Waves)
                    beat1_sorted = sort(beat1);
                    lower_thres = prctile(beat1_sorted,5);
                    upper_thres = prctile(beat1_sorted,95);
                    inds_to_keep = (beat1_sorted <= lower_thres) | (beat1_sorted >= upper_thres);
                    beat1_extreme = beat1_sorted(inds_to_keep);
                    
                    beat2_sorted = sort(beat2);
                    lower_thres = prctile(beat2_sorted,5);
                    upper_thres = prctile(beat2_sorted,95);
                    inds_to_keep = (beat2_sorted <= lower_thres) | (beat2_sorted >= upper_thres);
                    beat2_extreme = beat2_sorted(inds_to_keep);
                    
                    [p1, edges] = histcounts(beat1_extreme, nbins, 'Normalization', 'probability');
                    p2 = histcounts(beat2_extreme, edges, 'Normalization', 'probability');
                    eps_val = 1e-10;
                    p1 = p1 + eps_val;
                    p2 = p2 + eps_val;
                    m = 0.5 * (p1 + p2); %Intermediate distribution
                    kl1 = sum(p1 .* log(p1 ./ m));
                    kl2 = sum(p2 .* log(p2 ./ m));
                    jsd = 0.5 * (kl1 + kl2);
                    M = jsd;  %M(i,j)
                    O = sqrt(jsd); %O(i,j)
                    breakflag = 1;
                    break
                case 'dtw'
                    M(i,j) = dtw(b1, b2);
                case 'emd'
                    nbins = varargin{1};
                    beat1 = beat1 - mean(beat1);  % Center
                    beat1 = beat1 / norm(beat1);  % Normalize
                    beat2 = beat2 - mean(beat2);
                    beat2 = beat2 / norm(beat2);
                    %Check distribution of extreme values (Waves)
                    beat1_sorted = sort(beat1);
                    lower_thres = prctile(beat1_sorted,5);
                    upper_thres = prctile(beat1_sorted,95);
                    inds_to_keep = (beat1_sorted <= lower_thres) | (beat1_sorted >= upper_thres);
                    beat1_extreme = beat1_sorted(inds_to_keep);
                    
                    beat2_sorted = sort(beat2);
                    lower_thres = prctile(beat2_sorted,5);
                    upper_thres = prctile(beat2_sorted,95);
                    inds_to_keep = (beat2_sorted <= lower_thres) | (beat2_sorted >= upper_thres);
                    beat2_extreme = beat2_sorted(inds_to_keep);
                    
                    [p1, edges] = histcounts(beat1_extreme, nbins, 'Normalization', 'probability');
                    p2 = histcounts(beat2_extreme, edges, 'Normalization', 'probability');
                    %p1 = b1 / sum(b1);
                    %p2 = b2 / sum(b2);
                    emd_val = sum(abs(cumsum(p1) - cumsum(p2)));
                    max_emd_1 = sum(abs(cumsum(p1) - cumsum(sort(p1, 'descend'))));
                    max_emd_2 = sum(abs(cumsum(p2) - cumsum(sort(p2, 'descend'))));
                    max_emd = max(max_emd_1, max_emd_2);
                    M = emd_val / max_emd; %M(i,j)
                    breakflag = 1;
                    break
                otherwise
                    error('Unknown metric');
            end  
        end
        if breakflag
            break
        end
    end
    if (strcmp(metric,'xcorr') | strcmp(metric,'jsd'))
        varargout{1} = O;
        if 
    end
    
    
end
